<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序卡片式轮播图]]></title>
    <url>%2F2018%2F10%2F15%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8D%A1%E7%89%87%E5%BC%8F%E8%BD%AE%E6%92%AD%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[前言国庆休息了一周，加上上周没有特别想写的技术，于是半个月过去了，没写博文。今天研究了一下小程序卡片式轮播图的制作。在上一个小程序，我们的设计师也设计了一个这样的卡片式轮播图，但是由于当时时间比较紧凑，没有办法很好的实现，于是就用了最普通的轮播图样式，今天正好有时间给我研究了一下，因此写一篇博文记录一下。 效果图老规矩，先上一个效果图 小程序轮播组件这里我是在小程序的轮播组件的基础上进行了修改，有想自己手写轮播图的兄dei这篇对你的帮助不太大。 wxml跟普通的轮播图组件一样，将官方的swiper组件代码复制下来就好 1234567&lt;swiper class="swiper" indicator-dots="true" current="&#123;&#123;current&#125;&#125;" autoplay="true" circular="true" bindchange="changeSwiper"&gt; &lt;block wx:for="&#123;&#123;images&#125;&#125;" wx:for-index="index"&gt; &lt;swiper-item class="&#123;&#123;current == index ? 'active' : ''&#125;&#125;"&gt; &lt;image src="&#123;&#123;item.url&#125;&#125;" class="slide-image" mode="aspectFill" /&gt; &lt;/swiper-item&gt; &lt;/block&gt;&lt;/swiper&gt; ⚠️ 这里要注意的是，我们在切换轮播图的时候要监听轮播图的下标，也就是current，并且当current与for循环的下标index相等的时候，给他一个active的类。 JavsScript在逻辑层只要获取当前的轮播图下标，并且将他的值赋值给current即可。 12345changeSwiper: function (e) &#123; this.setData(&#123; current: e.detail.current &#125;)&#125; wxsswxss是重点，我们可以看到上边的层级， 轮播图由一个大的 swiper 包裹着数个swiper-item构成 并且swiper-item包裹着一个image标签 因此我们只要 将swiper-item的宽度缩小，在页面上就能显示三张图片（左右两个不是完整的，并且需要调一下left值） 然后把image标签大小缩小的原来的.9x，那么在图片之间就会有空隙 最后把当前轮播图（带active的swiper-item）的image标签大小恢复为1x，那么切换轮播图的时候，就会有大小的变化了 最后我们再加上大小变化的过渡效果transition: all .3s ease-in-out 就完成了卡片式轮播图的制作 12345678910111213141516171819202122swiper &#123; width: 100%; height: 300rpx;&#125;swiper-item &#123; position: relative; width: 80% !important; left: 75rpx;&#125;image &#123; transform: scale(.9); transition: all .3s ease; border-radius: 16rpx;&#125;.active &gt; image &#123; transform: scale(1); transition: all .3s ease; &#125; 附上完整的项目github地址 https://github.com/583175694/swiperCard]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序调用腾讯地图]]></title>
    <url>%2F2018%2F09%2F30%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E8%85%BE%E8%AE%AF%E5%9C%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[腾讯位置服务第一步，我们先找到腾讯位置服务，找到其中的微信小程序JavaScript SDK，接着做好准备工作： 申请开发者密钥（key）：申请密钥 下载微信小程序JavaScriptSDK，微信小程序JavaScriptSDK v1.0 安全域名设置，在“设置” -&gt; “开发设置”中设置request合法域名，添加https://apis.map.qq.com 实名认证 创建key 设置key这里一定要注意把最下面的WebSeriveAPI勾选 选择地图样式 API有很多api，你们自行去看吧..这里展示一下地点搜索 wxml123456789&lt;!--绑定点击事件--&gt;&lt;button bindtap="nearby_search"&gt;搜索周边KFC&lt;/button&gt;&lt;!--地图容器--&gt;&lt;map id="myMap" markers="&#123;&#123;markers&#125;&#125;" style="width:100%;height:300px;" longitude="116.313972" latitude="39.980014" scale='16'&gt;&lt;/map&gt; js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293// 引入SDK核心类var QQMapWX = require('../../utils/qqmap-wx-jssdk.js');var qqmapsdk;Page(&#123; data: &#123; location: '', inputValue: '', markers: [] &#125;, onLoad: function () &#123; // 实例化API核心类 qqmapsdk = new QQMapWX(&#123; key: 'EO5BZ-VG5RJ-5MNFX-FFUOY-3PP3T-LOBCM' &#125;); &#125;, onShow: function () &#123; &#125;, nearby_search() &#123; var _this = this; // 调用接口 qqmapsdk.search(&#123; keyword: 'kfc', //搜索关键词 location: '39.980014,116.313972', //设置周边搜索中心点 success: function (res) &#123; //搜索成功后的回调 var mks = [] for (var i = 0; i &lt; res.data.length; i++) &#123; mks.push(&#123; // 获取返回结果，放到mks数组中 title: res.data[i].title, id: res.data[i].id, latitude: res.data[i].location.lat, longitude: res.data[i].location.lng, iconPath: "/image/icon_location.png", //图标路径 width: 20, height: 20 &#125;) &#125; _this.setData(&#123; //设置markers属性，将搜索结果显示在地图中 markers: mks &#125;) &#125;, fail: function (res) &#123; console.log(res); &#125;, complete: function (res) &#123; console.log(res); &#125; &#125;); &#125;, onSelect() &#123; var that = this; qqmapsdk.search(&#123; keyword: this.data.inputValue, // location: '39.980014,116.313972', //设置周边搜索中心点 success: function (res) &#123; console.log(res.data); that.setData(&#123; location: res.data[0].location &#125;) var mks = [] for (var i = 0; i &lt; res.data.length; i++) &#123; mks.push(&#123; // 获取返回结果，放到mks数组中 title: res.data[i].title, id: res.data[i].id, latitude: res.data[i].location.lat, longitude: res.data[i].location.lng, iconPath: "/image/icon_location.png", //图标路径 width: 20, height: 25 &#125;) &#125; that.setData(&#123; //设置markers属性，将搜索结果显示在地图中 markers: mks &#125;) &#125;, fail: function (res) &#123; console.log(res); &#125;, complete: function (res) &#123; console.log(res); &#125; &#125;) &#125;, onHref() &#123; wx.navigateTo(&#123; url: '../index2/index2', &#125;) &#125;&#125;) 效果 OK，代码自行复制去试试吧，谢谢大家]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过protobuf.js与后端进行交互]]></title>
    <url>%2F2018%2F09%2F14%2F%E9%80%9A%E8%BF%87protobuf.js%E4%B8%8E%E5%90%8E%E7%AB%AF%E8%BF%9B%E8%A1%8C%E4%BA%A4%E4%BA%92%2F</url>
    <content type="text"><![CDATA[获取 *.protp文件后端完成了接口之后，将.proto 文件发给你 编译 *.protp文件将*.proto文件编译成ts、js文件，这里我是将命令写成一个脚本，运行npm run proto即可编译 123&#123; "proto": "pbjs -t static-module -w commonjs -o ./src/proto/ProtoServices.js ./src/proto/*.proto --no-encode --no-create --no-decode &amp;&amp; pbts -o ./src/proto/ProtoServices.d.ts ./src/proto/ProtoServices.js --no-encode --no-create --no-decode"&#125; 这里其实存在两条命令，分别是：1pbjs -t static-module -w commonjs -o ./src/proto/ProtoServices.js ./src/proto/*.proto --no-encode --no-create --no-decode 1pbts -o ./src/proto/ProtoServices.d.ts ./src/proto/ProtoServices.js --no-encode --no-create --no-decode 第一句是：通过 ./src/proto/ 路径下的所有proto文件生成 ProtoServices.js 文件，目录在 ./src/proto/ 下 第二句是：通过 新生成的 ProtoServices.js文件生成一份 ProtoServices.d.ts文件，目录在 ./src/proto/ 下 获取泛型生成了ts之后呢，提取他其中的泛型，这里获取了他三种泛型 发起的请求的泛型 服务器的响应的泛型 回调的对象的泛型 12345678910111213141516171819202122232425262728/** 秘钥对象的泛型 */interface ICosCredentials &#123; /** CosCredentials sessionToken */ sessionToken?: (string|null); /** CosCredentials tmpSecretId */ tmpSecretId?: (string|null); /** CosCredentials tmpSecretKey */ tmpSecretKey?: (string|null);&#125;/** 这个响应的泛型定义 */interface IGetCosCredentialsResponse &#123; credentials?: (ICosCredentials|null);&#125;/** 定义这个请求的泛型 */ interface IGetCosCredentialsRequest &#123; /** Hash ID */ hashId?: (string|null);&#125; 封装底层方法 ES7的语法async异步地执行这个函数 接收request参数（已经定义好了request请求的泛型） 返回Promise回调（已经定义好了Promise响应的泛型） 因此，这里我们调用的时候，只需要将data作为参数传递过去，就能拿到服务器的回调 123456789101112131415161718async function getCosCredentials(request: IGetCosCredentialsRequest): Promise&lt;IGetCosCredentialsResponse|null&gt; &#123; try &#123; const url = getGlobalData('getCosSecretKey'); let cosSecretKey = await Taro.request&lt;IGetCosCredentialsResponse&gt;(&#123; url: url, data: request, method: 'POST', &#125;) console.log(cosSecretKey) return cosSecretKey.data &#125; catch (error) &#123; return null &#125;&#125; 客户端使用方法export一个函数，调用刚刚封装的方法，将{hashId：XXX}作为参数传过去，获取到服务器的返回值赋值给response（响应），然后通过dispatch方法将{getCosSuccess: response}作为参数，用中间件的方法传入Redux（此处省略很多字）。 123456789101112131415161718192021222324// ⚠️获取COS秘钥export const getCosSecretKey = () =&gt; &#123; return async (dispatch: ThunkDispatch&lt;RootState, null, AnyAction&gt;, getState: () =&gt; RootState) =&gt; &#123; let response = await getCosCredentials(&#123;hashId: "XXX"&#125;) console.log(response) dispatch(getCosSecretSuccess(&#123; getCosSuccess: response &#125;)) &#125;&#125;// 获取cos秘钥成功export const GET_COS_SECRET_SUCCESS = 'GET_COS_SECRET_SUCCESS'export interface getCosSecretSuccess &#123; getCosSuccess: any&#125;export const getCosSecretSuccess = createAction( GET_COS_SECRET_SUCCESS, (payload: getCosSecretSuccess) =&gt; &#123; return payload &#125;) 执行结果 彩蛋这里呢其实我是另辟蹊径了，正确的姿势来说呢，最底层封装好的方法应该是在执行 npm run proto 命令的时候，在生成的 .js 文件中已经封装好了的，在客户端我直接使用就好了的。但是生成的 .js文件有特么七千行代码..= = 不知道是我生成的姿势不对还是怎么样，因此自己封装了一遍底层的函数。以后有更好的方法直接使用 *.js封装的代码的话，会再写一篇博客告诉大家]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>JavaScript</tag>
        <tag>http</tag>
        <tag>protpbuf.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[纯CSS实现视差滚动效果]]></title>
    <url>%2F2018%2F09%2F12%2F%E7%BA%AFCSS%E5%AE%9E%E7%8E%B0%E8%A7%86%E5%B7%AE%E6%BB%9A%E5%8A%A8%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言视差滚动效果大家可能都听过，基本上都是JS实现的，有对应插件 – Parallax.js. 实际上，如果你对兼容性要求不是很高，比方说忽略IE浏览器，则我们使用简单的几行CSS代码就可以实现视差滚动效果了。 先上效果图 目前，Chrome以及FireFox等浏览器（不包括IE11在内的浏览器）都是有效果。 CSS实现部分1234567891011121314151617181920212223242526272829303132333435363738394041424344div &#123; box-sizing: border-box;&#125;#container &#123; /* 滚动容器 */ position: fixed; top: 0; left: 0; right: 0; bottom: 0; perspective: 1px; // 3D视图 overflow-x: hidden; overflow-y: scroll;&#125;#group1 &#123; /* 视差元素的父级需要3D视角 */ height: 1000px; position: relative; transform-style: preserve-3d; font-size: 20px;&#125;.background &#123; /* 滚动比较慢的背景元素 */ transform: translateZ(-1px); height: 500px; width: 100%; position: absolute; top: 0; background: #FF8A8A; padding-top: 100px;&#125;.foreground &#123; position: absolute; top: 500px; height: 500px; width: 100%; background: #23819C; opacity: 0.8; padding-top: 100px;&#125; HTML部分12345678910&lt;div id='container'&gt; &lt;div id="group1"&gt; &lt;div class="background"&gt; &lt;center&gt;I'm an element far away.&lt;/center&gt; &lt;/div&gt; &lt;div class="foreground"&gt; &lt;center&gt;I'm an element close by.&lt;/center&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 大家可以注意上面代码出现了一个1px(来自perspective), 一个-1px(来自transform)以及scale(2)中的2. 这几个数字之间有什么关系呢？ 实现原理我们先看下面这个3D视角示意图(来自这里) 当我们在屏幕前面1个单位的地方，看屏幕后面1个单位的元素，肉眼所见的画面大小只有实际的1/2，即所谓的近大远小。此时scale(2)让内容放大到原来2倍，正好在平面上看上去好像是原来大小。 虽然肉眼所见体积似乎是1:1，但是，滚动时候的位移变化还是1:2, 应该很好理解。举个极端的例子，我们坐在电瓶车上看天上的月亮，虽然车子在40码的速度奔啊奔，但是，好像月亮的位置没有移动，一直就在头顶。网页中的3D就是模拟真实世界的3D效果，因此，也会有这种视差体验。 或者这么讲吧，CSS3 3D天然视差效果，滚动，只是视差体现的一个触发条件。 于是，如果我们想实现3层视差滚动怎么办？很简单，来个transform: translateZ(-2px)试试~ 结语据我测试，直接body或html滚动似乎难以实现视差滚动效果，不过天色已晚，我没深究，有兴趣的小伙伴可以研究分享下。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redux初体验]]></title>
    <url>%2F2018%2F08%2F28%2FRedux%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[前言花了一个星期，把设计稿给重构完毕了（所以也有一星期没有发博客了）。今天呢研究了一下Redux的用法，我发现实际运用Redux的时候好像没有之前写的Demo这么简单。写一篇博客来记录一下今天Redux的初体验。听说在React框架里边用到Redux的话，那么交互部分都在Redux里面完成。那么我这里写一个获取登录信息的逻辑吧。 Part 1在actions里面声明一个函数getUserInfo，这个函数呢返回了一个带着dispatch以及getState两个方法的匿名函数。这个函数采用了ES7语法的异步处理（async、await）⚠️ await 必须在带有async的函数才能使用。然后呢这里调用了Taro框架的方法获取到了openid以及微信个人信息等一系列资料，我准备把这些资料放到Redux里面。 12345678910111213141516171819202122export const getUserInfo = () =&gt; &#123; const that = this return async (dispatch: ThunkDispatch&lt;RootState, null, AnyAction&gt;, getState: () =&gt; RootState) =&gt; &#123; try &#123; let userLogin = await Taro.login() let checkSession = await Taro.checkSession() let userInfo = await Taro.getUserInfo() const url = getGlobalData('openidUrl')+'?appid=' + GlobalData.appid + '&amp;secret=' + GlobalData.secret + '&amp;js_code=' + userLogin.code + '&amp;grant_type=authorization_code'; let openidData = await Taro.request(&#123; url: url, data: &#123;&#125;, method: 'GET', &#125;); dispatch(userLoginSuccess(&#123; data: openidData.data &#125;)) &#125; catch (error) &#123; console.error(`Login response error: $&#123;error&#125;`) &#125; &#125;&#125; 于是我在这里用中间件的方法，将Reducer在异步操作结束后自动执行（详细资料可以参考阮一峰Redux入门教程（二）：中间件与异步操作） 1234567891011// 获取openid成功export const USER_LOGON_SUCCESS = 'USER_LOGON_SUCCESS'export interface getOpenidSuccess &#123; data: any&#125;export const userLoginSuccess = createAction( USER_LOGON_SUCCESS, (payload: getOpenidSuccess) =&gt; &#123; return payload &#125;) 输出的结果是这样的 好了，那么我在action已经能输出这个值了，只要在reducer里面把state替换掉应该就OK了 part 2首先在 actions引入常量 USER_LOGON_SUCCESS ，然后我定义了一个方法userLoginSuccess将action的值打包成一个对象返回出来，最后通过[USER_LOGON_SUCCESS]: userLoginSuccess将这个对象存储到Redux就行了。这里有两点要注意 ⚠️ 从其他文件引入任何东西的时候，都使用 { } ⚠️ 在使用handleActions方法的时候必须带一个默认状态 defaultStatus 1234567891011121314151617181920import &#123;USER_LOGON_SUCCESS&#125; from '../actions/counter'import &#123; handleActions, Action, Reducer &#125; from "redux-actions";let defaultStatus = &#123; userLoginSuccess:&#123;&#125;&#125;function userLoginSuccess(state, action)&#123; console.log(action.payload) return Object.assign(&#123;&#125;,state, action.payload)&#125;export const homeReducer = handleActions( &#123; [USER_LOGON_SUCCESS]: userLoginSuccess &#125;, defaultStatus);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[steps简易步骤条的制作]]></title>
    <url>%2F2018%2F08%2F21%2Fsteps%E7%AE%80%E6%98%93%E6%AD%A5%E9%AA%A4%E6%9D%A1%E7%9A%84%E5%88%B6%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[前言这是来到新公司的第一篇博客，上周学习了一周React、Redux、TypeScript，这周可以干活了。今天看了设计稿，十分的好看，特别是那块步骤条。好看的同时呢，实现起来好像还是有些难度，花了一个多钟的时间把步骤条给写了出来，那么现在我来分享一下吧 先上效果图 让我们开始吧html部分这里的HTML部分十分的简单，但是我用的是React里边的TSX语法，这里放出来大家需要的话自行转化成HTML语法就好了 1234567891011render () &#123; return ( &lt;View className='addServiceAPage'&gt; &lt;View class="steps"&gt; &lt;View className="stepsList active"&gt;名称&lt;/View&gt; &lt;View className="stepsList"&gt;价格&lt;/View&gt; &lt;View className="stepsList"&gt;简介、图片&lt;/View&gt; &lt;/View&gt; &lt;/View&gt; ) &#125; 再放一个精简版本供大家复制粘贴吧 12345&lt;ul class="steps"&gt; &lt;li class="active"&gt;名称&lt;/li&gt; &lt;li&gt;价格&lt;/li&gt; &lt;li&gt;简介、图片&lt;/li&gt;&lt;/ul&gt; css部分css代码有点长，我一步一步来解释 1234567891011121314.steps &#123; position: relative; margin-bottom: 30px; counter-reset: step; /*创建步骤数字计数器*/&#125;/*步骤描述*/.steps li &#123; list-style-type: none; font-size: 12px; text-align: center; width: 33%; position: relative; float: left;&#125; 首先先把ul和三个li排版好，让它浮动偏左，或者用Flex布局都可以，并设置好它的宽度。这里要注意的是css的counter-reset属性，对部分和子部分进行编号（比如 “Section 1”、”1.1”、”1.2”），这里我用它定义每个步骤的编号 12345678910111213141516171819202122232425262728/*步骤数字*/.steps li:before &#123; display: block; content: counter(step); /*设定计数器内容*/ counter-increment: step; /*计数器值递增*/ width: 32px; height: 32px; background-color: #019875; line-height: 32px; border-radius: 32px; font-size: 16px; color: #fff; text-align: center; font-weight: 700; margin: 0 auto 8px auto;&#125; /*连接线*/.steps li ~ li:after &#123; content: ''; width: 100%; height: 2px; background-color: #019875; position: absolute; left: -50%; top: 15px; z-index: -1; /*放置在数字后面*/&#125; 这里用了 :before，:after两个伪类分别定义步骤条里边的编号和它们的连接线。特别注意 content: counter(step); 和 counter-increment: step;，这里将父元素定义的编号在这里渲染出来。 123456789101112/*将当前/完成步骤之前的数字及连接线变绿*/.steps li.active:before,.steps li.active:after &#123; background-color: #019875;&#125; /*将当前/完成步骤之后的数字及连接线变灰*/.steps li.active ~ li:before,.steps li.active ~ li:after &#123; background-color: #777;&#125; 最后设置 active属性，改变高亮前后的编号背景颜色以及连接线的背景颜色 The end.. 多谢大家的观看]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[平安集团校招官网动画过渡效果]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%B9%B3%E5%AE%89%E9%9B%86%E5%9B%A2%E6%A0%A1%E6%8B%9B%E5%AE%98%E7%BD%91%E5%8A%A8%E7%94%BB%E8%BF%87%E6%B8%A1%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[前言最近公司接了一个平安集团校招官网的项目，毕竟人家平安集团是个大企业嘛，那这个项目就必须得高端大气上档次呀，因此我就按照设计师的要求在许多地方加入了动画的过渡效果，也有一两周没更新博客了，那正好看看关于css的这简单酷炫的动画效果吧 The first part效果： css关键代码：1234567891011121314151617181920212223242526.c_content &#123; opacity: 0; background: rgba(0, 0, 0, 0.5); transition: all 0.4s ease; &amp;:hover &#123; opacity: 1; h3 &#123; -webkit-transform: translateY(0); opacity: 1; &#125; .c_about &#123; -webkit-transform: translateY(0); opacity: 0.8; &#125; &#125; h3 &#123; -webkit-transform: translateY(40px); transition: all 0.4s ease; opacity: 0; &#125; .c_about &#123; opacity: 0; -webkit-transform: translateY(40px); transition: all 0.4s ease 0.1s; &#125; &#125; 代码解析：可能gif图太快了，效果看的不太清，非常的简单，我们只要考虑两个地方： 背景：先设置半透明黑色背景的透明度opacity:0，并且加入过渡属性transition，然后在:hover 选择器的时候将透明度opacity:1，即可。 文字：透明度和背景一样，先设置opacity:0，在:hover选择器执行的时候设置opacity:1。 接着设置他们的位置，在默认情况下位置是transform: translateY(40px);Y轴负方向偏移40px 在:hover选择器执行的时候设置transform: translateY(0);偏移量为0 即可 更厉害点的效果： The second part效果： css关键代码：1234567891011121314151617181920212223242526272829303132333435li &#123; transform: translateY(350px); opacity: 0;&#125;.actived &#123; transform: translateY(0) !important; opacity: 1;&#125;li:first-of-type &#123; -webkit-transition: all 0.8s ease; -o-transition: all 0.8s ease; -moz-transition: all 0.8s ease; transition: all 0.8s ease;&#125;li:nth-of-type(2) &#123; -webkit-transition: all 1.3s ease; -o-transition: all 1.3s ease; -moz-transition: all 1.3s ease; transition: all 1.3s ease;&#125;li:nth-of-type(3) &#123; -webkit-transition: all 1.8s ease; -o-transition: all 1.8s ease; -moz-transition: all 1.8s ease; transition: all 1.8s ease;&#125;li:nth-of-type(4) &#123; -webkit-transition: all 2.3s ease; -o-transition: all 2.3s ease; -moz-transition: all 2.3s ease; transition: all 2.3s ease;&#125; 代码解析：这四个卡片最外层是四个&lt; li &gt;标签，我先判断页面的滚动距离，如果滚动距离达到了四个卡片的位置的话，卡片就添加 actived 属性。这里很好理解，就是当滚动距离达到了相应位置，将位置从下边350px 的地方变成0px 而已，关键在于first-of-type与nth-of-type(n) 属性，规定属于其父元素的第n个子元素的每个子元素 。所以我们把每个&lt; li &gt;标签设置不同的过渡时间即可。 还有一种效果 The third part效果： css关键代码：1234567891011121314151617181920212223242526.title &#123; transform: translateY(350px); opacity: 0; transition: all 1s ease;&#125; .title &#123; transform: translateY(0) !important; transition: all 1.2s ease; opacity: 1;&#125; #menu li &#123; width: 30px; transition: all 0.6s ease;&#125;#menu a &#123; transition: all 0.6s ease; opacity: 0;&#125;#menu .active a &#123; opacity: 1;&#125;#menu .active &#123; width: 53px;&#125; 代码解析：这里用了一个Fullpage.js的JQuery插件，全屏翻页效果。动画效果分为文字部分和导航条部分 文字部分：翻页的时候会添加 actived属性，那么在文字默认效果是 位置在下方350px；透明度为 0；过渡时间 1s； actived属性的效果是 位置为0px；透明度为 1；即可做到文字上浮效果 导航栏部分：默认的时候长度为30px；文字透明度为 0；actived属性的时候 长度为53px；透明度为 1，即可]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序封装get和post]]></title>
    <url>%2F2018%2F07%2F26%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B0%81%E8%A3%85get%E5%92%8Cpost%2F</url>
    <content type="text"><![CDATA[首先我们先创建一个配置文件配置各种基础常量。config.js123456var config = &#123; APPID: 'your id', BASE_URL:'your url',&#125;//暴露接口module.exports = config; util.js123456789101112131415161718192021222324252627282930313233343536373839404142var config = require('config.js');//引入配置文件。function Get(url,data,cb)&#123; wx.showNavigationBarLoading();//顶部显示loading效果 wx.request(&#123; url: config.BASE_URL + url, data:data, success:(res) =&gt; &#123; typeof cb == "function" &amp;&amp; cb(res.data,""); wx.hideNavigationBarLoading();//顶部隐藏loading效果 &#125;, fail:(err) =&gt; &#123; typeof cb == "function" &amp;&amp; cb(null,err.errMsg); console.log("get 请求:" + config.BASE_URL); console.log(err) wx.hideNavigationBarLoading(); &#125; &#125;)&#125;;function Post(url, data, cb) &#123; wx.request(&#123; method: 'POST', url: config.BASE_URL + url, data: data, header:&#123; "Content-Type": "application/x-www-form-urlencoded"//跨域请求 &#125;, success: (res) =&gt; &#123; typeof cb == "function" &amp;&amp; cb(res.data, ""); &#125;, fail: (err) =&gt; &#123; typeof cb == "function" &amp;&amp; cb(null, err.errMsg); console.log("post 请求:" + config.BASE_URL); console.log(err); &#125; &#125;);&#125;;//暴露接口module.exports = &#123; httpGet: Get, httpPost: Post&#125; 其中的cb作为一个回调函数，执行返回成功时的操作。至此我们成功封装了微信小程序的get和post两个方法。在index.js使用如下：1234567891011var http = require('../../utils/util.js');Page(&#123; data: &#123; &#125;, onLoad:function()&#123; http.httpGet("?action=index", &#123;appid: config.APPID,&#125;, function (res) &#123; console.log(res); &#125;); &#125;); &#125; &#125;)]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>微信小程序</tag>
        <tag>JavaScript</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序WebScoket的应用]]></title>
    <url>%2F2018%2F07%2F20%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8FWebScoket%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言荔园土木人这个项目接近尾声了，终于是有时间写一篇关于WebSocket的博客了。之前我把聊天的界面给搭建出来了，但是还没有完成真正的一个聊天系统，那么现在，就是完善的时候了。 wx.connectSocket(OBJECT)创建一个 WebSocket连。接很简单，就三行代码。这个是后端给我的Socket地址，小程序记得将这个地址列为合法域名 123wx.connectSocket(&#123; url: 'wss://socket.szucceaa.com/?fid=' + wx.getStorageSync('userInfo').id + '&amp;tid=' + e.id&#125;) wx.onSocketOpen(CALLBACK)监听WebSocket连接打开事件，因为socket是一个长连接，要在onSocketOpen事件里面才能一直接收服务器发送过来的广播。 1234567891011121314151617181920212223wx.onSocketOpen(function (res) &#123; that.setData(&#123; socketOpen: true &#125;) console.log('WebSocket连接已打开！') // 接收消息 wx.onSocketMessage(function (res) &#123; var obj = &#123;&#125;; obj.receive = false; obj.content = res.data; that.data.chatData.push(obj); that.setData(&#123; chatData: that.data.chatData &#125;) &#125;) wx.onSocketClose(function (res) &#123; console.log('WebSocket连接已关闭！'); that.connectSocket(e); &#125;)&#125;) 我的聊天的内容是一个数组对象chatData，然后对方给我发消息的话，chatData.receive是为false，从而判断是我发出去的还是对方给我发的。 因此接收消息的时候我建立了一个新数组obj，然后将服务器广播的内容和receive push到原数组chatData里面，双向绑定从而将数组在页面中渲染出来。 wx.onSocketMessage(CALLBACK)监听WebSocket接受到服务器的消息事件。这里呢其实在上面的代码已经展示了，onSocketMessage函数 1234567891011// 接收消息wx.onSocketMessage(function (res) &#123; var obj = &#123;&#125;; obj.receive = false; obj.content = res.data; that.data.chatData.push(obj); that.setData(&#123; chatData: that.data.chatData &#125;) that.sendMessage();&#125;) wx.sendSocketMessage(OBJECT)通过 WebSocket 连接发送数据，需要先 wx.connectSocket，并在 wx.onSocketOpen 回调之后才能发送。 这里我写了一个函数sendSocketMessage，在发送消息（bindconfirm事件）中调用， 12345678910111213141516171819// [发送消息]sendSocketMessage: function (msg) &#123; var that = this; if (that.data.socketOpen) &#123; wx.sendSocketMessage(&#123; data: msg &#125;) that.setData(&#123; chatData: that.data.chatData &#125;) &#125; else &#123; console.log('发送失败'); wx.showToast(&#123; title: '发送失败', icon: 'none', duration: 1200 &#125;) &#125;&#125;, 也非常的简单，先判断socket是否已经连接，然后sendSocketMessage发送一条data。 关键代码 123wx.sendSocketMessage(&#123; data: msg&#125;) wx.closeSocket(OBJECT)关闭 WebSocket 连接。我在页面卸载的时候调用了这个api，当页面关闭时，关闭socket连接 1234567onUnload() &#123; wx.closeSocket(); wx.onSocketClose(function (res) &#123; console.log('WebSocket连接已关闭！'); &#125;)&#125;, wx.onSocketClose(CALLBACK)监听WebSocket关闭，我有两个地方调用这个api，因为后台的socket时效性是一分钟，那么一分钟过去了就要重启打开socket。所以第一个地方是在connectSocket这个方法里面，当监听到socket连接断开的时候，重新执行connectSocket这个方法，这样一个轮询可保证socket不会中途断开。 第二个地方就是页面卸载的时候了，判断socket是否关闭成功 123456789101112131415161718192021222324252627282930313233343536// [打开socket]connectSocket: function (e) &#123; var that = this; if (wx.getStorageSync('userInfo').id == e.id) &#123; console.log('不能与自己聊天'); return false &#125; wx.connectSocket(&#123; url: 'wss://socket.szucceaa.com/?fid=' + wx.getStorageSync('userInfo').id + '&amp;tid=' + e.id &#125;) wx.onSocketOpen(function (res) &#123; that.setData(&#123; socketOpen: true &#125;) console.log('WebSocket连接已打开！') // 接收消息 wx.onSocketMessage(function (res) &#123; var obj = &#123;&#125;; obj.receive = false; obj.content = res.data; that.data.chatData.push(obj); that.setData(&#123; chatData: that.data.chatData &#125;) that.sendMessage(); &#125;) wx.onSocketClose(function (res) &#123; console.log('WebSocket连接已关闭！'); that.connectSocket(e); &#125;) &#125;)&#125;, 这样子就完成了一个聊天系统的开发，上一个效果图。 …等等，再做一个聊天列表就完善了吧。 聊天列表由于聊天列表那块并没有建立socket，只是普通的request请求。那为了接收信息即时性，这里我做了一个轮询，当请求成功时过两秒钟再次请求。 1234567891011121314151617181920// [获取列表数据]getChatData() &#123; var that = this; var token = 'bearer' + ' ' + wx.getStorageSync('userToken').access_token; var data = &#123; page: that.data.page, per_page: that.data.paginal &#125; var header = &#123; Accept: 'application/json', Authorization: token &#125; utils.httpGet('api/users/own/conversations', data, header, function (res) &#123; if (res.status == 200) &#123; that.setData(&#123; ChatArr: that.data.ChatArr &#125;) &#125; &#125;)&#125;, 但是这里遇到了一个问题，请求到的数组全部渲染到页面上去吗？这个样子页面性能消耗挺大的吧。因此我这里做了一个操作，比较两个数组，将不同的值ubshift到最上边 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647if (res.status == 200) &#123; if (that.data.ChatArr.length == 0) &#123; that.data.ChatArr = res.data.data that.setData(&#123; ChatArr: that.data.ChatArr &#125;) &#125; else &#123; var result = []; for (var i = 0; i &lt; res.data.data.length; i++) &#123; var obj1 = res.data.data[i]; var num1 = obj1.news; var isExist = false; for (var j = 0; j &lt; that.data.ChatArr.length; j++) &#123; var obj2 = that.data.ChatArr[j]; var num2 = obj2.news; if (num2 == num1&amp;&amp;obj1.unread == obj2.unread) &#123; isExist = true; break; &#125; &#125; if (!isExist) &#123; result.push(obj1); &#125; &#125; if (result.length) &#123; for (var i = 0; i &lt; that.data.ChatArr.length; i++) &#123; if (that.data.ChatArr[i].id == result[0].id) &#123; that.data.ChatArr.splice(i, 1); break; &#125; &#125; that.data.ChatArr.unshift(result[0]); that.setData(&#123; ChatArr: that.data.ChatArr &#125;) console.log(that.data.ChatArr); &#125; &#125; that.data.timeout = setTimeout(() =&gt; &#123; that.getChatData(); that.setData(&#123; // ChatArr: [] &#125;) &#125;, 2000);&#125; 有点长，反正逻辑就上边说的这样，慢慢看吧hhh，今天就到这了，放个图看看]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常用命令]]></title>
    <url>%2F2018%2F07%2F06%2FGit%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[查看、添加、提交、删除、找回，重置修改文件git help # 显示command的help git show # 显示某次提交的内容 git show $id git co – # 抛弃工作区修改 git co . # 抛弃工作区修改 git add # 将工作文件修改提交到本地暂存区 git add . # 将所有修改过的工作文件提交暂存区 git rm # 从版本库中删除文件 git rm –cached # 从版本库中删除文件，但不删除文件 git reset # 从暂存区恢复到工作文件 git reset – . # 从暂存区恢复到工作文件 git reset –hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改 git ci git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am “some comments” git ci –amend # 修改最后一次提交记录 git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象 git revert HEAD # 恢复最后一次提交的状态 查看文件diffgit diff # 比较当前文件和暂存区文件差异 git diff git diff # 比较两次提交之间的差异 git diff .. # 在两个分支之间比较 git diff –staged # 比较暂存区和版本库差异 git diff –cached # 比较暂存区和版本库差异 git diff –stat # 仅仅比较统计信息 查看提交记录git log git log # 查看该文件每次提交记录 git log -p # 查看每次详细修改内容的diff git log -p -2 # 查看最近两次详细修改内容的diff git log –stat #查看提交统计信息 tigMac上可以使用tig代替diff和log，brew install tig Git 本地分支管理查看、切换、创建和删除分支 git br -r # 查看远程分支 git br &lt;new_branch&gt; # 创建新的分支 git br -v # 查看各个分支最后提交信息 git br –merged # 查看已经被合并到当前分支的分支 git br –no-merged # 查看尚未被合并到当前分支的分支 git co # 切换到某个分支 git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去 git co -b &lt;new_branch&gt; # 基于branch创建新的new_branch git co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除 git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支 git br -d # 删除某个分支 git br -D # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase git merge # 将branch分支合并到当前分支 git merge origin/master –no-ff # 不要Fast-Foward合并，这样可以生成merge提交 git rebase master # 将master rebase到branch，相当于： git co &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge Git补丁管理(方便在多台机器上开发同步时用)git diff &gt; ../sync.patch # 生成补丁 git apply ../sync.patch # 打补丁 git apply –check ../sync.patch #测试补丁能否成功 Git暂存管理git stash # 暂存 git stash list # 列所有stash git stash apply # 恢复暂存的内容 git stash drop # 删除暂存区 Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地 git pull –no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并 git fetch origin # 抓取远程仓库更新 git merge origin/master # 将远程主分支合并到本地当前分支 git co –track origin/branch # 跟踪某个远程分支创建相应的本地分支 git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push # push所有分支 git push origin master # 将本地主分支推到远程主分支 git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库) git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名 git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支 git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d )，然后再push删除远程分支 Git远程仓库管理git remote -v # 查看远程服务器地址和仓库名称 git remote show origin # 查看远程服务器仓库状态 git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址 git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm # 删除远程仓库 创建远程仓库git clone –bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库 scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上 mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git –bare init # 在服务器创建纯仓库 git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址 git push -u origin master # 客户端首次提交 git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且track git remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库 git branch –set-upstream master origin/master git branch –set-upstream develop origin/develop 转载自：https://www.cnblogs.com/cspku/articles/Git_cmds.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序上拉加载更多(分页加载)]]></title>
    <url>%2F2018%2F07%2F02%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%8A%E6%8B%89%E5%8A%A0%E8%BD%BD%E6%9B%B4%E5%A4%9A(%E5%88%86%E9%A1%B5%E5%8A%A0%E8%BD%BD)%2F</url>
    <content type="text"><![CDATA[前言当用户打开一个页面时，假设后台数据量庞大时，一次性地返回所有数据给客户端，页面的打开速度就会有所下降，而且用户只看上面的内容而不需要看后面的内容时，也浪费用户流量，基于优化的角度来考虑，后台不要一次性返回所有数据，当用户有需要再往下翻的时候，再加载更加数据出来。 上拉加载更多业务需求：列表滚动到底部时，继续往上拉，加载更多内容 必备参数： page –页数 per_page –每页个数 其他参数：根据接口的所需参数 实现原理：当第一次访问接口时，传递2个必备参数（第1次加载，需要返回数据的个数为15个），和其他参数（需要搜索的字符串）给后台，后台返回第一次数据过来。在请求成功的的回调函数中，判断返回的数据是否&gt;0，是，则取出数据，渲染视图层，并把“上拉加载”显示在列表底部；否，则没有数据可取，并把“没有更多”显示在列表底部，同时把“上拉加载”隐藏掉。 当用户已经滚动到列表底部（这里使用到小程序提供的scroll-view组件的bindscrolltolower事件），触发bindscrolltolower事件，参数page+1，再把2个必备参数（第2次加载，需要返回数据的个数为15个）和其他参数（需要搜索的字符串）给后台，后台把其余的数据返回给前台，前台在原来数据的基础上添加数据。 html 123&lt;scroll-view scroll-y="true" style="height:100%;" bindscrolltolower="onReachBottom"&gt; &lt;!-- 中间部分 --&gt;&lt;/scroll-view&gt; JavaScript 12345678// 页面上拉触底事件的处理函数onReachBottom: function () &#123; var that = this; that.data.page = that.data.page + 1; // 异步请求 that.getNewData(that.data.page, that.data.per_page);&#125;, JSON 123&#123; "onReachBottomDistance": 40&#125; 这样子就实现了上拉加载更多，十分的简单。有机会我写一篇下拉刷新的功能。到这里就结束了，谢谢大家的观看]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不定高度动态元素height CSS3过渡动画]]></title>
    <url>%2F2018%2F07%2F01%2F%E4%B8%8D%E5%AE%9A%E9%AB%98%E5%BA%A6%E5%8A%A8%E6%80%81%E5%85%83%E7%B4%A0height%20CSS3%E8%BF%87%E6%B8%A1%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[摘要这是一篇关于小程序扩展效果的制作 小程序view点击扩展效果 view点击扩展动画效果 小程序view点击扩展效果遇到了一个业务需求，活动报名人数如果过多的话，只显示前两行头像，如图 这个十分的简单，只要通过点击事件改变它的style就好，我这里是这么写的 html123&lt;view class="content_portrait &#123;&#123;extend?'content_portrait_extend':''&#125;&#125;"&gt; // 中间元素省略&lt;/view&gt; CSS123456789101112131415/* 元素未扩展 */.content_portrait &#123; width: 710rpx; height: 172rpx; overflow: hidden; display: flex; flex-wrap: wrap; justify-content: flex-start; &#125;/* 元素已扩展 */.content_portrait_extend &#123; height: auto; overflow: auto;&#125; JavaScript12345678910openExtend: function () &#123; this.setData(&#123; extend: true &#125;)&#125;,closeExtend: function () &#123; this.setData(&#123; extend: false &#125;)&#125; view点击扩展动画效果如果扩展的时候有个过度效果的话那用户体验可以说是非常舒服了。 但是这里遇到了点问题。就是我们的高度不确定的，扩展完毕之后的高度是auto。但是如果队列最后边高度是auto的话，animation并不能实现动画效果，怎么办呢？ 于是这里我想了一个办法，我们可以用 max-height。毕竟 max-height 是支持 transition动画的。 CSS123456789101112131415.content_portrait_extend &#123; height: auto; overflow: auto; animation: animat_extend 2s linear; /* 展开时调用 animation动画队列*/&#125;@keyframes animat_extend &#123; 0% &#123; max-height: 172rpx; &#125; 100% &#123; max-height: 1720rpx; &#125;&#125; 这样就实现点击扩展时出现动画效果了，弊端在于如果中间元素大于max-height的话，那超出部分无法显示了，而且动画时长会根据max-height确定，所以动画时长也得慢慢调试。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css3</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序日期时间选择器以及组件封装]]></title>
    <url>%2F2018%2F06%2F29%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E5%99%A8%E4%BB%A5%E5%8F%8A%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[前言：微信小程序摒除了select，因为觉得这个在移动端的操作以及显示不友好，从而产生了picker，picker也就是从底部弹起的滚动选择器，现在支持的有5种，通过mode来区分。但是呢这5种并没有包括日期时间选择权（日期和时间同时存在于picker的选择器）。因此完这里自定义了一个日期时间选择器。 多列选择器：mode = multiSelector这里我们自定义选择器呢会用到多列选择器，它的api地址：这里 这里直接放代码吧HTML123456789&lt;view class="tui-picker-content"&gt; &lt;view class="tui-picker-name"&gt;日期时间选择器&lt;/view&gt; &lt;picker mode="multiSelector" value="&#123;&#123;dateTime&#125;&#125;" bindchange="changeDateTime" bindcolumnchange="changeDateTimeColumn1" range="&#123;&#123;dateTimeArray&#125;&#125;"&gt; &lt;view class="tui-picker-detail"&gt; 选择日期时间: &#123;&#123;dateTimeArray[0][dateTime[0]]&#125;&#125;-&#123;&#123;dateTimeArray[1][dateTime[1]]&#125;&#125;-&#123;&#123;dateTimeArray[2][dateTime[2]]&#125;&#125; &#123;&#123;dateTimeArray[3][dateTime[3]]&#125;&#125;:&#123;&#123;dateTimeArray[4][dateTime[4]]&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt; JavaScript1234567891011121314151617181920212223242526272829303132333435363738var dateTimePicker = require('../../utils/dateTimePicker.js');Page(&#123; data: &#123; date: '2018-10-01', time: '12:00', dateTimeArray: null, dateTime: null, startYear: 2000, endYear: 2050 &#125;, onLoad()&#123; // 获取完整的年月日 时分秒，以及默认显示的数组 var obj1 = dateTimePicker.dateTimePicker(this.data.startYear, this.data.endYear); // 精确到分的处理，将数组的秒去掉 var lastArray = obj1.dateTimeArray.pop(); var lastTime = obj1.dateTime.pop(); this.setData(&#123; dateTimeArray: obj1.dateTimeArray, dateTime: obj1.dateTime &#125;); &#125;, changeDateTime(e) &#123; this.setData(&#123; dateTime: e.detail.value &#125;); &#125;, changeDateTimeColumn(e) &#123; var arr = this.data.dateTime, dateArr = this.data.dateTimeArray; arr[e.detail.column] = e.detail.value; dateArr[2] = dateTimePicker.getMonthDay(dateArr[0][arr[0]], dateArr[1][arr[1]]); this.setData(&#123; dateTimeArray: dateArr, dateTime: arr &#125;); &#125;&#125;) 封装的组件dateTimePicker.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function withData(param) &#123; return param &lt; 10 ? '0' + param : '' + param;&#125;function getLoopArray(start, end) &#123; var start = start || 0; var end = end || 1; var array = []; for (var i = start; i &lt;= end; i++) &#123; array.push(withData(i)); &#125; return array;&#125;function getMonthDay(year, month) &#123; var flag = year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0), array = null; switch (month) &#123; case '01': case '03': case '05': case '07': case '08': case '10': case '12': array = getLoopArray(1, 31) break; case '04': case '06': case '09': case '11': array = getLoopArray(1, 30) break; case '02': array = flag ? getLoopArray(1, 29) : getLoopArray(1, 28) break; default: array = '月份格式不正确，请重新输入！' &#125; return array;&#125;function getNewDateArry() &#123; // 当前时间的处理 var newDate = new Date(); var year = withData(newDate.getFullYear()), mont = withData(newDate.getMonth() + 1), date = withData(newDate.getDate()), hour = withData(newDate.getHours()), minu = withData(newDate.getMinutes()), seco = withData(newDate.getSeconds()); return [year, mont, date, hour, minu, seco];&#125;function dateTimePicker(startYear, endYear, date) &#123; // 返回默认显示的数组和联动数组的声明 var dateTime = [], dateTimeArray = [[], [], [], [], [], []]; var start = startYear || 1978; var end = endYear || 2100; // 默认开始显示数据 var defaultDate = date ? [...date.split(' ')[0].split('-'), ...date.split(' ')[1].split(':')] : getNewDateArry(); // 处理联动列表数据 /*年月日 时分秒*/ dateTimeArray[0] = getLoopArray(start, end); dateTimeArray[1] = getLoopArray(1, 12); dateTimeArray[2] = getMonthDay(defaultDate[0], defaultDate[1]); dateTimeArray[3] = getLoopArray(0, 23); dateTimeArray[4] = getLoopArray(0, 59); dateTimeArray[5] = getLoopArray(0, 59); dateTimeArray.forEach((current, index) =&gt; &#123; dateTime.push(current.indexOf(defaultDate[index])); &#125;); return &#123; dateTimeArray: dateTimeArray, dateTime: dateTime &#125;&#125;module.exports = &#123; dateTimePicker: dateTimePicker, getMonthDay: getMonthDay&#125; 这里直接拿去用就完事了， 重点讲讲无比坑人的组件封装 组件封装由于许多地方都需要用到日期时间选择器，因此为了代码的简(zhuang)洁(bi)，我准备把它封装成一个组件，小程序自定义组件有点坑呐，反正官方看不到，我随便说hhh。这里picker是组件，index是需要使用组件的界面 构建目录首先先创建一个目录为了存放公用组件 Component构造器组件的构造跟普通的界面可不一样，它没有普通界面的生命周期（onLoad，onShow之类的），他的定义段和示例方法可以看这里 先奉上部分代码picker12345678910111213var dateTimePicker = require('../../utils/dateTimePicker.js');Component(&#123; data: &#123; &#125;, ready() &#123; &#125;, methods: &#123; &#125;&#125;) 这里我只用了众多定义段的其中三条，其他的自己去api里边看 data：组件的内部数据，和 properties 一同用于组件的模版渲染 ready：组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息（注意这里不是onLoad） methods：组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见 组件事件 我在methods里面放着日期时间选择器的changeDateTime、changeDateTimeColumn方法，在ready里边放着上边onLoad里面的代码（自己去上边看哈） 自定义组件我们要在自定义组件里面picker.json文件添加以下参数，意思是“我是组件” picker123&#123; "component": true&#125; 使用组件首先要在使用的地方的json文件添加以下参数 index12345&#123; "usingComponents": &#123; "my-picker": "/components/picker/picker" &#125;&#125; 这样的话我们自定义的组件的标签就是my-picker了，然后呢我们在页面里边使用他 index1&lt;my-picker class="picker" bindmyevent="onMyEventStart"&gt;&lt;/my-picker&gt; 组件的通讯这个组件是日期时间选择器嘛，所以得获取到选择好的时间，这里是这么写的 picker1234changeDateTime(e) &#123; var myEventDetail = e.currentTarget.dataset.time; this.triggerEvent('myevent', myEventDetail) &#125; 我们通过 myevent这个事件，将值 myEventDetail传入页面中。页面接收的方法是这样的 index1&lt;my-picker class="picker" bindmyevent="onMyEventStart"&gt;&lt;/my-picker&gt; bindmyevent 绑定了 ‘myevent’ 这个事件，这个事件如果触发了，执行onMyEventStart 方法 index123456// 活动开始时间 onMyEventStart: function (e) &#123; this.setData(&#123; dateStart: e.detail &#125;) &#125;, 如果需要多次调用这个组件的话，只要改变他的函数即可 index12&lt;my-picker class="picker" bindmyevent="onMyEventStart"&gt;&lt;/my-picker&gt; &lt;my-picker class="picker" bindmyevent="onMyEventEnd"&gt;&lt;/my-picker&gt; 123456789101112// 活动开始时间onMyEventStart: function (e) &#123; this.setData(&#123; dateStart: e.detail &#125;)&#125;,// 活动结束时间onMyEventEnd: function (e) &#123; this.setData(&#123; dateEnd: e.detail &#125;)&#125;, 效果 有点多，毕竟结合和两个模块，本想着要不分开写的，想想连着写效果还是好点。这里的代码复制过去应该能直接拿来用吧。好了今天就说到这里了，谢谢能看到最后的兄弟，希望能帮得到大家。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序模板消息实例]]></title>
    <url>%2F2018%2F06%2F29%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[摘要:这是一篇关于微信小程序模板消息的实例 模板消息管理：小程序API提供了五个方法 获取小程序模板库标题列表 获取模板库某个模板标题下关键词库 组合模板并添加至帐号下的个人模板库 获取帐号下已存在的模板列表 删除帐号下的某个模板 这里我没这么麻烦，我直接在微信公众平台手动配置了模板，详见小程序文档。这里我主要讲讲发送消息模版 发送模板消息：他要接收几个参数 参数 必填 说明 touser 是 接收者（用户）的 openid template_id 是 所需下发的模板消息的id page 否 点击模板卡片后的跳转页面，仅限本小程序内的页面。 form_id 是 表单提交场景下，为 submit 事件带上的 formId；支付场景下，为本次支付的 prepay_id data 是 模板内容，不填则下发空模板 color 否 模板内容字体的颜色，不填默认黑色 【废弃】 emphasis_keyword 否 模板需要放大的关键词，不填则默认无放大 好，让我一个一个来获取touser也就是获取用户的openid：这位兄弟已经写的非常清楚了，我的openid也是看着这篇博客做出来的，大家可以点进去学习学习。 template_id所需下发的模板消息的id：在微信公众平台里边的模板消息模块自行获取。 page点击模板之后跳转到的小程序的路径，可写可不写。 form_id这个关键了，你在form表单提交的时候得带上report-submit=”true”这个属性 123&lt;form report-submit="true" bindsubmit="formSubmit"&gt; &lt;button formType="submit" class="next"&gt;提交报名&lt;/button&gt; &lt;/form&gt; 于是乎他就能返回 formid 123 formSubmit: function (e) &#123; console.log(e.detail.formId);&#125; ⚠️ 注意： formid在微信开发者工具里面并不能输出出来，必须得真机运行。 formid只能用一次，下次若还想发送模板消息，得重新获取formid formid有效期仅七天 data模板内容，不填则下发空模板，我的是这么写的： 123456789101112131415161718192021222324&#123; "touser": that.data.openid, "template_id": "2ST8VFURGEIFtwHZbkudmUwYb401Y8pzugctTkFC_Os", "page": "../mineActivity/mineActivity", "form_id": that.data.formid, "data": &#123; "keyword1": &#123; "value": "校友沙龙" &#125;, "keyword2": &#123; "value": "2019年01月05日 12:30" &#125;, "keyword3": &#123; "value": "深圳大学" &#125;, "keyword4": &#123; "value": "广东省深圳市南山区深圳大学" &#125;, "keyword5": &#123; "value": "15876092583" &#125; &#125;, "emphasis_keyword": "keyword1.DATA"&#125; 获取到了POST参数，我们可以发起请求了12345678910111213141516171819202122232425262728293031323334353637function wxhttp() &#123; wx.request(&#123; method: 'POST', url: 'https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=' + that.data.access_token, data: &#123; "touser": that.data.openid, "template_id": "2ST8VFURGEIFtwHZbkudmUwYb401Y8pzugctTkFC_Os", "page": "../mineActivity/mineActivity", "form_id": that.data.formid, "data": &#123; "keyword1": &#123; "value": "校友沙龙" &#125;, "keyword2": &#123; "value": "2019年01月05日 12:30" &#125;, "keyword3": &#123; "value": "深圳大学" &#125;, "keyword4": &#123; "value": "广东省深圳市南山区深圳大学" &#125;, "keyword5": &#123; "value": "15876092583" &#125; &#125;, "emphasis_keyword": "keyword1.DATA" &#125;, header: header, success: (res) =&gt; &#123; console.log('发送成功' + res) &#125;, fail: (err) =&gt; &#123; console.log('请求失败' + err) &#125; &#125;);&#125;; 效果 这里呢可能客户有一个需求，就是群发消息模版。当我发起一个活动时，所有使用此小程序的用户都会收到一条活动消息通知（需求不是特别合理，咱这里只讨论技术，不讨论业务需求hhh），这块呢我仅有一个思路，具体实现还需要后端的帮忙，如果出来了呢会给大家发布一篇群发消息模版的实例。在此谢谢大家的观看了。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序聊天系统]]></title>
    <url>%2F2018%2F06%2F27%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[摘要：这是一篇关于小程序聊天系统的制作 聊天界面如何布局 聊天界面如何跑通逻辑 小程序聊天系统的制作：先上效果图 编辑之后的效果 好的，开始上代码首先呢进行页面布局，这是部分聊天框的代码，这部分我放在了标签里面，让它可进行滚动 1234567891011121314151617&lt;view class="time"&gt;2018-02-16 13:08&lt;/view&gt;&lt;!-- 加了chat_reverse和reverse是对方发给我的信息 --&gt;&lt;view class="chat chat_reverse"&gt; &lt;view class="head"&gt;&lt;/view&gt; &lt;view class="send reverse"&gt; &lt;text&gt;周末有空吗&lt;/text&gt; &lt;view class="arrow"&gt;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;!-- 没有chat_reverse和reverse是我发给对方信息 --&gt;&lt;view class="chat"&gt; &lt;view class="send"&gt; &lt;text&gt;有的，周末你想去哪儿吗有的，周末你想去哪儿吗&lt;/text&gt; &lt;view class="arrow"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="head"&gt;&lt;/view&gt;&lt;/view&gt; 这里有一个要注意的地方和一个难点： 聊天框得自适应对不对，不能给他固定一个width，因此呢我给了他一个最大宽度 max-width，那么他在超过最大宽度时候就可以换行。 难点呢在于聊天框的箭头指向，就这个小小的三角形。我绞尽脑汁啊想到了一个办法。我发现如果不给div设置宽度和高度，只给他设置边框的话，那么这个边框就由四个小三角形组成。于是就有了下边的代码 123456789101112131415161718192021222324252627.send &#123; position: relative; top: 2rpx; width: auto; height: auto; max-width: 500rpx; background: #3c98e7; border-radius: 16px; /* 圆角 */ white-space: pre-wrap; display: inline-block;&#125;.send .arrow &#123; position: absolute; top: 4px; right: -24rpx; width: 0; height: 0; font-size: 0; border-top: 8rpx solid; border-left: 16rpx solid; border-bottom: 6rpx solid; border-right: 16rpx solid; border-color: transparent transparent transparent #3c98e7; transform: rotate(-28deg);&#125; 这里呢，父元素就是聊天框，子元素就是指向的箭头，聊天框相对定位，箭头绝对定位，将他的位置固定再聊天框边边那块地方。然后箭头的大小啊，位置啊，通过top、border-top等这几个元素慢慢调吧。这里我还给他设置了一个角度transform: rotate(-28deg); 那么到这里，界面构建的应该都没太大问题了吧？然后开始写一写逻辑部分。首先呢既然是聊天系统，你发送的话信息得出去吧。那么这里的逻辑是这样的： HTML部分1234567891011121314151617181920212223&lt;scroll-view scroll-y='true' scroll-top="&#123;&#123;scrollTop&#125;&#125;" class="content"&gt; &lt;view class="time"&gt;2018-02-16 13:08&lt;/view&gt; &lt;!-- 这里模拟聊天数据 --&gt; &lt;view class="chat &#123;&#123;item.receive?'':'chat_reverse'&#125;&#125;" wx:for="&#123;&#123;chatData&#125;&#125;" wx:key="index"&gt; &lt;!-- 如果对方发送消息，头像在左边 --&gt; &lt;view class="head" wx:if="&#123;&#123;!item.receive&#125;&#125;"&gt;&lt;/view&gt; &lt;view class="send &#123;&#123;item.receive?'':'reverse'&#125;&#125;"&gt; &lt;text&gt;&#123;&#123;item.content&#125;&#125;&lt;/text&gt; &lt;view class="arrow"&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 如果我发送消息，头像在右边 --&gt; &lt;view class="head" wx:if="&#123;&#123;item.receive&#125;&#125;"&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 底部的距离 --&gt; &lt;!-- &lt;view style="width: 100%;height: 120rpx;float:left;"&gt;&lt;/view&gt; --&gt;&lt;/scroll-view&gt;&lt;!-- 信息发送框 --&gt;&lt;view class="message"&gt; &lt;input value="&#123;&#123;mySend&#125;&#125;" placeholder="想说点什么..." placeholder-class="placeholder" confirm-type="send" bindconfirm="bindSend" maxlength="-1" /&gt;&lt;/view&gt; CSS部分12345678910111213bindSend: function(e) &#123; var that = this; var obj = &#123;&#125;; // 给他一个对象，存放将要发送的消息 console.log(e.detail.value); obj.content = e.detail.value; obj.receive = true; that.data.chatData.push(obj) that.setData(&#123; chatData: that.data.chatData, mySend: '' // 发送之后，这里将聊天框清空 &#125;) that.sendMessage(); &#125; 我用了 bindconfirm=”bindSend” 绑定键盘的完成按钮，当你放松时执行 bindSend，bindSend 的作用很简单，就是储存这一次的消息，并且 添加到消息的这个数组中的最后一位（这里还加了一个参数 receive，为了判断是我发送的还是我接收的）。 这里还有个稍难点就是每次发送完毕之后，页面应该是要滚动到最底部，才能看到最新的消息对不对，不然不符合用户体验。于是乎我用了这个方法： 123456sendMessage: function () &#123; var len = this.data.chatData.length //遍历的数组的长度 this.setData(&#123; scrollTop: 1000 * len // 这里我们的单对话区域最高1000，取了最大值，应该有方法取到精确的 &#125;); &#125; 代码很简单，我定义了一个值scrollTop，就是设置设置竖向滚动条位置，参考文档在这里，然后在scroll-view这个组建上的scroll-top属性绑定这个值就好了。 附送两个小技巧点击发送之后键盘不收起 1&lt;input confirm-type="send" bindconfirm="bindSend" confirm-hold="true"/&gt; 页面滚动到最底部时有个过度效果 1&lt;scroll-view scroll-y='true' scroll-with-animation="true"&gt; 好了，由于目前还没有对接后台，所以微信小程序聊天系统的讲解就先到这里了，对接后小程序的WebSocket方法我估计也会写一篇文章，在此多谢大家的观看了]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo博客初体验]]></title>
    <url>%2F2018%2F06%2F02%2F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[摘要：这是一篇关于小白如何使用Github Pages和Hexo搭建属于自己的博客： 如何使用和配置Hexo框架 如何将Hexo部署到自己的github项目中 前言：大学刚毕业，正式步入职业生涯了，碰巧回去授位的时候一位师弟告诉我说他创建了自己的博客，问我要不要也弄一个。好的，在他的帮助下完成了属于自己的博客。这职业生涯的第一篇博客，就写写如何搭建Hexo博客吧 一、环境配置安装node.js 下载node.js选择自己电脑版本的 安装git 下载git同样是根据电脑版本下载 下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。 鼠标邮件菜单里就多了Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。 二、Hexo安装①桌面鼠标右键，选择Git Bash Here，输入下面命令： npm install -g hexo-cli 如果出现说明hexo已经安装成功（针对windows） ②然后需要创建一个文件夹来存放hexo文件（相当于你的博客文件夹）例如：我在电脑上手动创建了一个名叫blog的文件夹，然后需要执行以下命令初始化： hexo init e:\blog 进入该目录： cd e:\blog 执行以下命令，系统会可以根据package.json文件中dependencies的配置安装所有依赖包： npm install 然后生成部署文件，启动本地服务 1.hexo g # hexo generate, 生成静态文件 2.hexo s # hexo server，可以在http://localhost:4000/ 查看 其他hexo命令用法可参考 Hexo官网 接下来我们可以在本地预览自己的博客了，打开http://localhost:4000/ 三、Github Pages配置顾名思义需要一个Github账号，然后创建一个仓库： 注意：仓库的名字必须是username/username.github.io注意：仓库的名字必须是username/username.github.io注意：仓库的名字必须是username/username.github.io例如：我的用户名为583175694,那么Repository name必须命名为：583175694.github.io重要的事情说三遍！！！（当初踩过的坑…）配置SSH密钥上传文件需要配置ssh key，所以首先需要检查本机电脑是否已经存在SSH keys，如果存在删除 .ssh文件夹里面的所有文件（如果不存在的忽略这条）然后设置下name和email git config --global user.name &quot;&lt;your name&gt;&quot; git config --global user.email &quot;&lt;your email&gt;&quot;name的名字随便起，email我建议填github同一个邮箱生成SSH密钥输入以下命令生成，邮箱是github里面注册的邮箱，ok回车： ssh-keygen -t rsa -C &quot;XXXXX@qq.com&quot;一路按回车键即可，如果设置了密码请记住。这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub获取SSH密钥 $ cat ~/.ssh/id_rsa.pub新建一个key，然后拷贝下生成的keykey粘贴刚刚生成的密钥，title随便起注意：重点圈起来，key下面的√记得一定要打哦！不然后面会报错，又是踩过的坑说多都是泪… 提交后，输入一下命令： ssh git@github.com 如果出现这样的内容： The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts. Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access. Connection to github.com closed. 大致恭喜你配置成功！！这时钥匙也变绿啦 四、部署到Github配置_config.yml 编辑刚刚新建的文件夹（e:/blog）根目录内,找到该文件，找到并修改Deployment部分（一般在最后） 注意：在每个填入前加个空格(否则会有错误)，其中repository填的是刚刚github新建仓库的SSH地址。 安装Git包，执行以下命令： npm install hexo-deployer-git --save cd到根目录，执行以下命令即可： hexo g hexo d now，你可以输入https://username.github.io来访问自己的博客啦（开森）！！！ 五、关于Hexo使用①更换主题 可以进入Hexo官网主题专栏找到自己想要的主题（个人强推：next） 找到想要的然后到克隆主题啦，十分简单，复制github地址输入一下命令： git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 成功后，你会发现themes文件夹里面多了一个注意文件夹 然后修改下根目录配置文件_config.yml里面的theme：主题名字（主题文件夹名字相同） 重新部署主题，Git Bash cd到根目录，输入一下命令： hexo g hexo s #本地预览 如果满意，就可以输入一下命令上传： hexo d ②新建博客文章 新建一篇文章(md文件)输入以下命令： hexo n &quot;文章标题&quot; 然后会在根目录/source/_posts 下生成你的文章文件，打开编辑器编辑就好（本人使用：MarkdownPad 2） 编写好后只要执行： hexo d -g 就会更新我们的Github库。 有关更多配置使用问题，可以参考Hexo官网文档 ~ 此文为转载，出处：https://583175694.github.io/]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
</search>
