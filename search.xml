<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[微信小程序日期时间选择器以及组件封装]]></title>
    <url>%2F2018%2F06%2F29%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E5%99%A8%E4%BB%A5%E5%8F%8A%E7%BB%84%E4%BB%B6%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[前言：微信小程序摒除了select，因为觉得这个在移动端的操作以及显示不友好，从而产生了picker，picker也就是从底部弹起的滚动选择器，现在支持的有5种，通过mode来区分。但是呢这5种并没有包括日期时间选择权（日期和时间同时存在于picker的选择器）。因此完这里自定义了一个日期时间选择器。 多列选择器：mode = multiSelector这里我们自定义选择器呢会用到多列选择器，它的api地址：这里 这里直接放代码吧HTML123456789&lt;view class="tui-picker-content"&gt; &lt;view class="tui-picker-name"&gt;日期时间选择器&lt;/view&gt; &lt;picker mode="multiSelector" value="&#123;&#123;dateTime&#125;&#125;" bindchange="changeDateTime" bindcolumnchange="changeDateTimeColumn1" range="&#123;&#123;dateTimeArray&#125;&#125;"&gt; &lt;view class="tui-picker-detail"&gt; 选择日期时间: &#123;&#123;dateTimeArray[0][dateTime[0]]&#125;&#125;-&#123;&#123;dateTimeArray[1][dateTime[1]]&#125;&#125;-&#123;&#123;dateTimeArray[2][dateTime[2]]&#125;&#125; &#123;&#123;dateTimeArray[3][dateTime[3]]&#125;&#125;:&#123;&#123;dateTimeArray[4][dateTime[4]]&#125;&#125; &lt;/view&gt; &lt;/picker&gt;&lt;/view&gt; JavaScript1234567891011121314151617181920212223242526272829303132333435363738var dateTimePicker = require('../../utils/dateTimePicker.js');Page(&#123; data: &#123; date: '2018-10-01', time: '12:00', dateTimeArray: null, dateTime: null, startYear: 2000, endYear: 2050 &#125;, onLoad()&#123; // 获取完整的年月日 时分秒，以及默认显示的数组 var obj1 = dateTimePicker.dateTimePicker(this.data.startYear, this.data.endYear); // 精确到分的处理，将数组的秒去掉 var lastArray = obj1.dateTimeArray.pop(); var lastTime = obj1.dateTime.pop(); this.setData(&#123; dateTimeArray: obj1.dateTimeArray, dateTime: obj1.dateTime &#125;); &#125;, changeDateTime(e) &#123; this.setData(&#123; dateTime: e.detail.value &#125;); &#125;, changeDateTimeColumn(e) &#123; var arr = this.data.dateTime, dateArr = this.data.dateTimeArray; arr[e.detail.column] = e.detail.value; dateArr[2] = dateTimePicker.getMonthDay(dateArr[0][arr[0]], dateArr[1][arr[1]]); this.setData(&#123; dateTimeArray: dateArr, dateTime: arr &#125;); &#125;&#125;) 封装的组件dateTimePicker.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980function withData(param) &#123; return param &lt; 10 ? '0' + param : '' + param;&#125;function getLoopArray(start, end) &#123; var start = start || 0; var end = end || 1; var array = []; for (var i = start; i &lt;= end; i++) &#123; array.push(withData(i)); &#125; return array;&#125;function getMonthDay(year, month) &#123; var flag = year % 400 == 0 || (year % 4 == 0 &amp;&amp; year % 100 != 0), array = null; switch (month) &#123; case '01': case '03': case '05': case '07': case '08': case '10': case '12': array = getLoopArray(1, 31) break; case '04': case '06': case '09': case '11': array = getLoopArray(1, 30) break; case '02': array = flag ? getLoopArray(1, 29) : getLoopArray(1, 28) break; default: array = '月份格式不正确，请重新输入！' &#125; return array;&#125;function getNewDateArry() &#123; // 当前时间的处理 var newDate = new Date(); var year = withData(newDate.getFullYear()), mont = withData(newDate.getMonth() + 1), date = withData(newDate.getDate()), hour = withData(newDate.getHours()), minu = withData(newDate.getMinutes()), seco = withData(newDate.getSeconds()); return [year, mont, date, hour, minu, seco];&#125;function dateTimePicker(startYear, endYear, date) &#123; // 返回默认显示的数组和联动数组的声明 var dateTime = [], dateTimeArray = [[], [], [], [], [], []]; var start = startYear || 1978; var end = endYear || 2100; // 默认开始显示数据 var defaultDate = date ? [...date.split(' ')[0].split('-'), ...date.split(' ')[1].split(':')] : getNewDateArry(); // 处理联动列表数据 /*年月日 时分秒*/ dateTimeArray[0] = getLoopArray(start, end); dateTimeArray[1] = getLoopArray(1, 12); dateTimeArray[2] = getMonthDay(defaultDate[0], defaultDate[1]); dateTimeArray[3] = getLoopArray(0, 23); dateTimeArray[4] = getLoopArray(0, 59); dateTimeArray[5] = getLoopArray(0, 59); dateTimeArray.forEach((current, index) =&gt; &#123; dateTime.push(current.indexOf(defaultDate[index])); &#125;); return &#123; dateTimeArray: dateTimeArray, dateTime: dateTime &#125;&#125;module.exports = &#123; dateTimePicker: dateTimePicker, getMonthDay: getMonthDay&#125; 这里直接拿去用就完事了， 重点讲讲无比坑人的组件封装 组件封装由于许多地方都需要用到日期时间选择器，因此为了代码的简(zhuang)洁(bi)，我准备把它封装成一个组件，小程序自定义组件有点坑呐，反正官方看不到，我随便说hhh。这里picker是组件，index是需要使用组件的界面 构建目录首先先创建一个目录为了存放公用组件 Component构造器组件的构造跟普通的界面可不一样，它没有普通界面的生命周期（onLoad，onShow之类的），他的定义段和示例方法可以看这里 先奉上部分代码picker12345678910111213var dateTimePicker = require('../../utils/dateTimePicker.js');Component(&#123; data: &#123; &#125;, ready() &#123; &#125;, methods: &#123; &#125;&#125;) 这里我只用了众多定义段的其中三条，其他的自己去api里边看 data：组件的内部数据，和 properties 一同用于组件的模版渲染 ready：组件生命周期函数，在组件布局完成后执行，此时可以获取节点信息（注意这里不是onLoad） methods：组件的方法，包括事件响应函数和任意的自定义方法，关于事件响应函数的使用，参见 组件事件 我在methods里面放着日期时间选择器的changeDateTime、changeDateTimeColumn方法，在ready里边放着上边onLoad里面的代码（自己去上边看哈） 自定义组件我们要在自定义组件里面picker.json文件添加以下参数，意思是“我是组件” picker123&#123; "component": true&#125; 使用组件首先要在使用的地方的json文件添加以下参数 index12345&#123; "usingComponents": &#123; "my-picker": "/components/picker/picker" &#125;&#125; 这样的话我们自定义的组件的标签就是my-picker了，然后呢我们在页面里边使用他 index1&lt;my-picker class="picker" bindmyevent="onMyEventStart"&gt;&lt;/my-picker&gt; 组件的通讯这个组件是日期时间选择器嘛，所以得获取到选择好的时间，这里是这么写的 picker1234changeDateTime(e) &#123; var myEventDetail = e.currentTarget.dataset.time; this.triggerEvent('myevent', myEventDetail) &#125; 我们通过 myevent这个事件，将值 myEventDetail传入页面中。页面接收的方法是这样的 index1&lt;my-picker class="picker" bindmyevent="onMyEventStart"&gt;&lt;/my-picker&gt; bindmyevent 绑定了 ‘myevent’ 这个事件，这个事件如果触发了，执行onMyEventStart 方法 index123456// 活动开始时间 onMyEventStart: function (e) &#123; this.setData(&#123; dateStart: e.detail &#125;) &#125;, 如果需要多次调用这个组件的话，只要改变他的函数即可 index12&lt;my-picker class="picker" bindmyevent="onMyEventStart"&gt;&lt;/my-picker&gt; &lt;my-picker class="picker" bindmyevent="onMyEventEnd"&gt;&lt;/my-picker&gt; 123456789101112// 活动开始时间onMyEventStart: function (e) &#123; this.setData(&#123; dateStart: e.detail &#125;)&#125;,// 活动结束时间onMyEventEnd: function (e) &#123; this.setData(&#123; dateEnd: e.detail &#125;)&#125;, 效果 有点多，毕竟结合和两个模块，本想着要不分开写的，想想连着写效果还是好点。这里的代码复制过去应该能直接拿来用吧。好了今天就说到这里了，谢谢能看到最后的兄弟，希望能帮得到大家。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序模板消息实例]]></title>
    <url>%2F2018%2F06%2F29%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A8%A1%E6%9D%BF%E6%B6%88%E6%81%AF%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[摘要:这是一篇关于微信小程序模板消息的实例 模板消息管理：小程序API提供了五个方法 获取小程序模板库标题列表 获取模板库某个模板标题下关键词库 组合模板并添加至帐号下的个人模板库 获取帐号下已存在的模板列表 删除帐号下的某个模板 这里我没这么麻烦，我直接在微信公众平台手动配置了模板，详见小程序文档。这里我主要讲讲发送消息模版 发送模板消息：他要接收几个参数 参数 必填 说明 touser 是 接收者（用户）的 openid template_id 是 所需下发的模板消息的id page 否 点击模板卡片后的跳转页面，仅限本小程序内的页面。 form_id 是 表单提交场景下，为 submit 事件带上的 formId；支付场景下，为本次支付的 prepay_id data 是 模板内容，不填则下发空模板 color 否 模板内容字体的颜色，不填默认黑色 【废弃】 emphasis_keyword 否 模板需要放大的关键词，不填则默认无放大 好，让我一个一个来获取touser也就是获取用户的openid：这位兄弟已经写的非常清楚了，我的openid也是看着这篇博客做出来的，大家可以点进去学习学习。 template_id所需下发的模板消息的id：在微信公众平台里边的模板消息模块自行获取。 page点击模板之后跳转到的小程序的路径，可写可不写。 form_id这个关键了，你在form表单提交的时候得带上report-submit=”true”这个属性 123&lt;form report-submit="true" bindsubmit="formSubmit"&gt; &lt;button formType="submit" class="next"&gt;提交报名&lt;/button&gt; &lt;/form&gt; 于是乎他就能返回 formid 123 formSubmit: function (e) &#123; console.log(e.detail.formId);&#125; ⚠️ 注意： formid在微信开发者工具里面并不能输出出来，必须得真机运行。 formid只能用一次，下次若还想发送模板消息，得重新获取formid formid有效期仅七天 data模板内容，不填则下发空模板，我的是这么写的： 123456789101112131415161718192021222324&#123; "touser": that.data.openid, "template_id": "2ST8VFURGEIFtwHZbkudmUwYb401Y8pzugctTkFC_Os", "page": "../mineActivity/mineActivity", "form_id": that.data.formid, "data": &#123; "keyword1": &#123; "value": "校友沙龙" &#125;, "keyword2": &#123; "value": "2019年01月05日 12:30" &#125;, "keyword3": &#123; "value": "深圳大学" &#125;, "keyword4": &#123; "value": "广东省深圳市南山区深圳大学" &#125;, "keyword5": &#123; "value": "15876092583" &#125; &#125;, "emphasis_keyword": "keyword1.DATA"&#125; 获取到了POST参数，我们可以发起请求了12345678910111213141516171819202122232425262728293031323334353637function wxhttp() &#123; wx.request(&#123; method: 'POST', url: 'https://api.weixin.qq.com/cgi-bin/message/wxopen/template/send?access_token=' + that.data.access_token, data: &#123; "touser": that.data.openid, "template_id": "2ST8VFURGEIFtwHZbkudmUwYb401Y8pzugctTkFC_Os", "page": "../mineActivity/mineActivity", "form_id": that.data.formid, "data": &#123; "keyword1": &#123; "value": "校友沙龙" &#125;, "keyword2": &#123; "value": "2019年01月05日 12:30" &#125;, "keyword3": &#123; "value": "深圳大学" &#125;, "keyword4": &#123; "value": "广东省深圳市南山区深圳大学" &#125;, "keyword5": &#123; "value": "15876092583" &#125; &#125;, "emphasis_keyword": "keyword1.DATA" &#125;, header: header, success: (res) =&gt; &#123; console.log('发送成功' + res) &#125;, fail: (err) =&gt; &#123; console.log('请求失败' + err) &#125; &#125;);&#125;; 效果 这里呢可能客户有一个需求，就是群发消息模版。当我发起一个活动时，所有使用此小程序的用户都会收到一条活动消息通知（需求不是特别合理，咱这里只讨论技术，不讨论业务需求hhh），这块呢我仅有一个思路，具体实现还需要后端的帮忙，如果出来了呢会给大家发布一篇群发消息模版的实例。在此谢谢大家的观看了。]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信小程序聊天系统]]></title>
    <url>%2F2018%2F06%2F27%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%81%8A%E5%A4%A9%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[摘要：这是一篇关于小程序聊天系统的制作 聊天界面如何布局 聊天界面如何跑通逻辑 小程序聊天系统的制作：先上效果图 编辑之后的效果 好的，开始上代码首先呢进行页面布局，这是部分聊天框的代码，这部分我放在了标签里面，让它可进行滚动 1234567891011121314151617&lt;view class="time"&gt;2018-02-16 13:08&lt;/view&gt;&lt;!-- 加了chat_reverse和reverse是对方发给我的信息 --&gt;&lt;view class="chat chat_reverse"&gt; &lt;view class="head"&gt;&lt;/view&gt; &lt;view class="send reverse"&gt; &lt;text&gt;周末有空吗&lt;/text&gt; &lt;view class="arrow"&gt;&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;&lt;!-- 没有chat_reverse和reverse是我发给对方信息 --&gt;&lt;view class="chat"&gt; &lt;view class="send"&gt; &lt;text&gt;有的，周末你想去哪儿吗有的，周末你想去哪儿吗&lt;/text&gt; &lt;view class="arrow"&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class="head"&gt;&lt;/view&gt;&lt;/view&gt; 这里有一个要注意的地方和一个难点： 聊天框得自适应对不对，不能给他固定一个width，因此呢我给了他一个最大宽度 max-width，那么他在超过最大宽度时候就可以换行。 难点呢在于聊天框的箭头指向，就这个小小的三角形。我绞尽脑汁啊想到了一个办法。我发现如果不给div设置宽度和高度，只给他设置边框的话，那么这个边框就由四个小三角形组成。于是就有了下边的代码 123456789101112131415161718192021222324252627.send &#123; position: relative; top: 2rpx; width: auto; height: auto; max-width: 500rpx; background: #3c98e7; border-radius: 16px; /* 圆角 */ white-space: pre-wrap; display: inline-block;&#125;.send .arrow &#123; position: absolute; top: 4px; right: -24rpx; width: 0; height: 0; font-size: 0; border-top: 8rpx solid; border-left: 16rpx solid; border-bottom: 6rpx solid; border-right: 16rpx solid; border-color: transparent transparent transparent #3c98e7; transform: rotate(-28deg);&#125; 这里呢，父元素就是聊天框，子元素就是指向的箭头，聊天框相对定位，箭头绝对定位，将他的位置固定再聊天框边边那块地方。然后箭头的大小啊，位置啊，通过top、border-top等这几个元素慢慢调吧。这里我还给他设置了一个角度transform: rotate(-28deg); 那么到这里，界面构建的应该都没太大问题了吧？然后开始写一写逻辑部分。首先呢既然是聊天系统，你发送的话信息得出去吧。那么这里的逻辑是这样的： HTML部分1234567891011121314151617181920212223&lt;scroll-view scroll-y='true' scroll-top="&#123;&#123;scrollTop&#125;&#125;" class="content"&gt; &lt;view class="time"&gt;2018-02-16 13:08&lt;/view&gt; &lt;!-- 这里模拟聊天数据 --&gt; &lt;view class="chat &#123;&#123;item.receive?'':'chat_reverse'&#125;&#125;" wx:for="&#123;&#123;chatData&#125;&#125;" wx:key="index"&gt; &lt;!-- 如果对方发送消息，头像在左边 --&gt; &lt;view class="head" wx:if="&#123;&#123;!item.receive&#125;&#125;"&gt;&lt;/view&gt; &lt;view class="send &#123;&#123;item.receive?'':'reverse'&#125;&#125;"&gt; &lt;text&gt;&#123;&#123;item.content&#125;&#125;&lt;/text&gt; &lt;view class="arrow"&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 如果我发送消息，头像在右边 --&gt; &lt;view class="head" wx:if="&#123;&#123;item.receive&#125;&#125;"&gt;&lt;/view&gt; &lt;/view&gt; &lt;!-- 底部的距离 --&gt; &lt;!-- &lt;view style="width: 100%;height: 120rpx;float:left;"&gt;&lt;/view&gt; --&gt;&lt;/scroll-view&gt;&lt;!-- 信息发送框 --&gt;&lt;view class="message"&gt; &lt;input value="&#123;&#123;mySend&#125;&#125;" placeholder="想说点什么..." placeholder-class="placeholder" confirm-type="send" bindconfirm="bindSend" maxlength="-1" /&gt;&lt;/view&gt; CSS部分12345678910111213bindSend: function(e) &#123; var that = this; var obj = &#123;&#125;; // 给他一个对象，存放将要发送的消息 console.log(e.detail.value); obj.content = e.detail.value; obj.receive = true; that.data.chatData.push(obj) that.setData(&#123; chatData: that.data.chatData, mySend: '' // 发送之后，这里将聊天框清空 &#125;) that.sendMessage(); &#125; 我用了 bindconfirm=”bindSend” 绑定键盘的完成按钮，当你放松时执行 bindSend，bindSend 的作用很简单，就是储存这一次的消息，并且 添加到消息的这个数组中的最后一位（这里还加了一个参数 receive，为了判断是我发送的还是我接收的）。 这里还有个稍难点就是每次发送完毕之后，页面应该是要滚动到最底部，才能看到最新的消息对不对，不然不符合用户体验。于是乎我用了这个方法： 123456sendMessage: function () &#123; var len = this.data.chatData.length //遍历的数组的长度 this.setData(&#123; scrollTop: 1000 * len // 这里我们的单对话区域最高1000，取了最大值，应该有方法取到精确的 &#125;); &#125; 代码很简单，我定义了一个值scrollTop，就是设置设置竖向滚动条位置，参考文档在这里，然后在scroll-view这个组建上的scroll-top属性绑定这个值就好了。 附送两个小技巧点击发送之后键盘不收起 1&lt;input confirm-type="send" bindconfirm="bindSend" confirm-hold="true"/&gt; 页面滚动到最底部时有个过度效果 1&lt;scroll-view scroll-y='true' scroll-with-animation="true"&gt; 好了，由于目前还没有对接后台，所以微信小程序聊天系统的讲解就先到这里了，对接后小程序的WebSocket方法我估计也会写一篇文章，在此多谢大家的观看了]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
      <tags>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建Hexo博客初体验]]></title>
    <url>%2F2018%2F06%2F02%2F%E6%90%AD%E5%BB%BAhexo%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[摘要：这是一篇关于小白如何使用Github Pages和Hexo搭建属于自己的博客： 如何使用和配置Hexo框架 如何将Hexo部署到自己的github项目中 前言：大学刚毕业，正式步入职业生涯了，碰巧回去授位的时候一位师弟告诉我说他创建了自己的博客，问我要不要也弄一个。好的，在他的帮助下完成了属于自己的博客。这职业生涯的第一篇博客，就写写如何搭建Hexo博客吧 一、环境配置安装node.js 下载node.js选择自己电脑版本的 安装git 下载git同样是根据电脑版本下载 下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。 鼠标邮件菜单里就多了Git GUI Here和Git Bash Here两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。 二、Hexo安装①桌面鼠标右键，选择Git Bash Here，输入下面命令： npm install -g hexo-cli 如果出现说明hexo已经安装成功（针对windows） ②然后需要创建一个文件夹来存放hexo文件（相当于你的博客文件夹）例如：我在电脑上手动创建了一个名叫blog的文件夹，然后需要执行以下命令初始化： hexo init e:\blog 进入该目录： cd e:\blog 执行以下命令，系统会可以根据package.json文件中dependencies的配置安装所有依赖包： npm install 然后生成部署文件，启动本地服务 1.hexo g # hexo generate, 生成静态文件 2.hexo s # hexo server，可以在http://localhost:4000/ 查看 其他hexo命令用法可参考 Hexo官网 接下来我们可以在本地预览自己的博客了，打开http://localhost:4000/ 三、Github Pages配置顾名思义需要一个Github账号，然后创建一个仓库： 注意：仓库的名字必须是username/username.github.io注意：仓库的名字必须是username/username.github.io注意：仓库的名字必须是username/username.github.io例如：我的用户名为583175694,那么Repository name必须命名为：583175694.github.io重要的事情说三遍！！！（当初踩过的坑…）配置SSH密钥上传文件需要配置ssh key，所以首先需要检查本机电脑是否已经存在SSH keys，如果存在删除 .ssh文件夹里面的所有文件（如果不存在的忽略这条）然后设置下name和email git config --global user.name &quot;&lt;your name&gt;&quot; git config --global user.email &quot;&lt;your email&gt;&quot;name的名字随便起，email我建议填github同一个邮箱生成SSH密钥输入以下命令生成，邮箱是github里面注册的邮箱，ok回车： ssh-keygen -t rsa -C &quot;XXXXX@qq.com&quot;一路按回车键即可，如果设置了密码请记住。这一步在~/.ssh/下生成了两个文件id_rsa 和 id_rsa.pub获取SSH密钥 $ cat ~/.ssh/id_rsa.pub新建一个key，然后拷贝下生成的keykey粘贴刚刚生成的密钥，title随便起注意：重点圈起来，key下面的√记得一定要打哦！不然后面会报错，又是踩过的坑说多都是泪… 提交后，输入一下命令： ssh git@github.com 如果出现这样的内容： The authenticity of host &apos;github.com (192.30.252.128)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added &apos;github.com,192.30.252.128&apos; (RSA) to the list of known hosts. Hi git-xuhao! You&apos;ve successfully authenticated, but GitHub does not provide shell access. Connection to github.com closed. 大致恭喜你配置成功！！这时钥匙也变绿啦 四、部署到Github配置_config.yml 编辑刚刚新建的文件夹（e:/blog）根目录内,找到该文件，找到并修改Deployment部分（一般在最后） 注意：在每个填入前加个空格(否则会有错误)，其中repository填的是刚刚github新建仓库的SSH地址。 安装Git包，执行以下命令： npm install hexo-deployer-git --save cd到根目录，执行以下命令即可： hexo g hexo d now，你可以输入https://username.github.io来访问自己的博客啦（开森）！！！ 五、关于Hexo使用①更换主题 可以进入Hexo官网主题专栏找到自己想要的主题（个人强推：next） 找到想要的然后到克隆主题啦，十分简单，复制github地址输入一下命令： git clone https://github.com/iissnan/hexo-theme-next(此处地址替换成你需要使用的主题的地址) 成功后，你会发现themes文件夹里面多了一个注意文件夹 然后修改下根目录配置文件_config.yml里面的theme：主题名字（主题文件夹名字相同） 重新部署主题，Git Bash cd到根目录，输入一下命令： hexo g hexo s #本地预览 如果满意，就可以输入一下命令上传： hexo d ②新建博客文章 新建一篇文章(md文件)输入以下命令： hexo n &quot;文章标题&quot; 然后会在根目录/source/_posts 下生成你的文章文件，打开编辑器编辑就好（本人使用：MarkdownPad 2） 编写好后只要执行： hexo d -g 就会更新我们的Github库。 有关更多配置使用问题，可以参考Hexo官网文档 ~ 此文为转载，出处：https://583175694.github.io/]]></content>
      <categories>
        <category>Github</category>
      </categories>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
</search>
